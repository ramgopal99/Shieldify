import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs/promises";
import path from "path";
import * as crypto from "crypto";
import { NextResponse } from "next/server";

const execAsync = promisify(exec);

// Define vulnerability patterns to check
const vulnerabilityPatterns = {
  sqlInjection: {
    pattern: /(?:SELECT|INSERT|UPDATE|DELETE|UNION|DROP).*(?:\$\{.*\}|\'.*\'|\?)/i,
    message:
      "Potential SQL injection vulnerability detected. Use parameterized queries instead.",
  },
  xss: {
    pattern: /(?:innerHTML|outerHTML|document\.write|eval\()/i,
    message: "Potential XSS vulnerability detected. Use safe DOM manipulation methods.",
  },
  hardcodedSecrets: {
    pattern: /(?:password|secret|key|token|api[_-]?key).*?=.*?['"`][^'"`]+['"`]/i,
    message: "Hardcoded credentials detected. Use environment variables instead.",
  },
  commandInjection: {
    pattern: /(?:exec|spawn|execSync)\s*\(/i,
    message: "Command injection risk detected. Validate and sanitize inputs.",
  },
  insecureRandomness: {
    pattern: /Math\.random\(\)/i,
    message: "Insecure randomness detected. Use crypto.getRandomValues() for cryptographic operations.",
  },
};

async function createTempDir(): Promise<string> {
  const tempDir = path.join(process.cwd(), "temp", crypto.randomBytes(16).toString("hex"));
  await fs.mkdir(tempDir, { recursive: true });
  return tempDir;
}

async function cleanupTempDir(tempDir: string): Promise<void> {
  try {
    await fs.rm(tempDir, { recursive: true, force: true });
  } catch (error) {
    console.error("Error cleaning up temp directory:", error);
  }
}

async function cloneRepository(githubUrl: string, tempDir: string): Promise<void> {
  try {
    const cloneCommand = `git clone ${githubUrl} ${tempDir}`;
    console.log(`Cloning repository with command: ${cloneCommand}`);
    await execAsync(cloneCommand);
  } catch (error) {
    throw new Error("Failed to clone repository. Please check the URL and try again.");
  }
}

// Scan a file for vulnerabilities and include line numbers
async function scanFile(filePath: string): Promise<string[]> {
  const vulnerabilities: string[] = [];
  const fileContent = await fs.readFile(filePath, "utf-8");

  const lines = fileContent.split("\n");

  // Check each pattern in the file content
  for (const { pattern, message } of Object.values(vulnerabilityPatterns)) {
    lines.forEach((line, index) => {
      if (pattern.test(line)) {
        vulnerabilities.push(`[${path.basename(filePath)} - Line ${index + 1}] ${message}`);
      }
    });
  }

  return vulnerabilities;
}

async function scanDirectory(dir: string): Promise<{ file: string; issues: string[] }[]> {
  const results: { file: string; issues: string[] }[] = [];

  async function scan(currentPath: string) {
    const entries = await fs.readdir(currentPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(currentPath, entry.name);

      // Skip unnecessary directories
      if (entry.name === "node_modules" || entry.name === ".git") continue;

      if (entry.isDirectory()) {
        await scan(fullPath);
      } else if (entry.isFile() && /\.(js|ts|jsx|tsx|py|php|rb)$/.test(entry.name)) {
        const issues = await scanFile(fullPath);
        if (issues.length > 0) {
          results.push({ file: fullPath, issues });
        }
      }
    }
  }

  await scan(dir);
  return results;
}

export async function POST(req: Request) {
  try {
    const { githubUrl } = await req.json();

    // Validate GitHub URL
    const githubUrlPattern = /^https:\/\/github\.com\/[\w-]+\/[\w-]+(\.git)?$/;
    if (!githubUrlPattern.test(githubUrl)) {
      return NextResponse.json({ error: "Invalid GitHub URL format" }, { status: 400 });
    }

    const tempDir = await createTempDir();

    try {
      // Clone repository
      await cloneRepository(githubUrl, tempDir);

      // Scan for vulnerabilities
      const vulnerabilities = await scanDirectory(tempDir);

      return NextResponse.json({
        vulnerabilities: vulnerabilities.length > 0 ? vulnerabilities : "No vulnerabilities detected.",
      });
    } finally {
      await cleanupTempDir(tempDir);
    }
  } catch (error) {
    console.error("Error processing request:", error);
    return NextResponse.json({ error: "Failed to process repository" }, { status: 500 });
  }
}
